#!/bin/bash

docker_resolve()
{
    local container="$1"

    ns_pid=$(docker inspect --format='{{ .State.Pid }}' ${container} 2>/dev/null)
    if [[ "$?" != "0" || -z "${ns_pid}" || "${ns_pid}" == "0" ]]; then
        echo "ERROR: Failed to find a running Docker container '${container}'."
        exit 1
    fi
}

create_netns()
{
    local ns_pid="$1"

    [ ! -d /var/run/netns ] && (mkdir -p /var/run/netns 2>/dev/null || {
        echo "ERROR: Failed to create /var/run/netns directory."
        exit 1
    })

    [ -f /var/run/netns/${ns_pid} ] && (rm -f /var/run/netns/${ns_pid} || {
        echo "ERROR: Unable to remove previous netns directory."
        exit 1
    })

    ln -s /proc/${ns_pid}/ns/net /var/run/netns/${ns_pid} || {
        echo "ERROR: Unable to link netns directory."
        exit 1
    }

    # Register hook that will free the netns on exit
    trap "free_netns ${ns_pid}" EXIT
}

free_netns()
{
    local ns_pid="$1"

    [ -h /var/run/netns/${ns_pid} ] && rm -f /var/run/netns/${ns_pid}
}

netcfg_bridge()
{
    local container="$1"
    local host_if="$2"
    local guest_if="$3"

    docker_resolve ${container}
    create_netns ${ns_pid}

    # Create a bridge if one does not yet exist
    if [ ! -d /sys/class/net/${host_if} ]; then
        ip link add dev ${host_if} type bridge || {
            echo "ERROR: Failed to create bridge '${host_if}'."
            exit 1
        }

        ip link set ${host_if} up || {
            echo "ERROR: Failed to bring bridge '${host_if}' up."
            exit 1
        }
    fi

    # Create veth interface pair
    local veth_host="v${guest_if}h${ns_pid}"
    local veth_guest="v${guest_if}g${ns_pid}"
    ip link add name ${veth_host} mtu 1500 type veth peer name ${veth_guest} mtu 1500 || {
        echo "ERROR: Failed to create veth interface pair!"
        exit 1
    }

    # Join host interface to the bridge and bring it up
    ip link set ${veth_host} master ${host_if} || {
        # Try to cleanup after ourselves
        ip link delete dev ${veth_host} 2>/dev/null

        echo "ERROR: Failed to join host interface '${veth_host}' into bridge '${host_if}'."
        exit 1
    }

    ip link set ${veth_host} up || {
        # Try to cleanup after ourselves
        ip link delete dev ${veth_host} 2>/dev/null

        echo "ERROR: Failed to bring up host interface '${veth_host}'."
        exit 1
    }

    # Move guest interface into the container namespace and rename it
    ip link set ${veth_guest} netns ${ns_pid} || {
        # Try to cleanup after ourselves
        ip link delete dev ${veth_host} 2>/dev/null

        echo "ERROR: Failed to move guest interface into the container namespace."
        exit 1
    }

    ip netns exec ${ns_pid} ip link set ${veth_guest} name ${guest_if} || {
        # Try to cleanup after ourselves
        ip link delete dev ${veth_host} 2>/dev/null

        echo "ERROR: Failed to rename guest interface."
        exit 1
    }

    ip netns exec ${ns_pid} ip link set ${guest_if} up || {
        # Try to cleanup after ourselves
        ip link delete dev ${veth_host} 2>/dev/null

        echo "ERROR: Failed to bring guest interface '${guest_if}' up."
        exit 1
    }

    free_netns ${ns_pid}
}

netcfg_exists()
{
    local container="$1"
    local guest_if="$2"

    docker_resolve ${container}
    create_netns ${ns_pid}

    if [ -z "$(ip netns exec ${ns_pid} ip link sh dev ${guest_if} up 2>/dev/null)" ]; then
        exit 1
    fi

    free_netns ${ns_pid}
}

if [ "$(whoami)" != "root" ]; then
    echo "ERROR: Need to be root to configure networking."
    exit 1
fi

case "$1" in
    bridge)
        shift
        netcfg_bridge "$@"
        ;;

    exists)
        shift
        netcfg_exists "$@"
        ;;

    *)
        echo "Usage:"
        echo "  $0 bridge <container> <host-if> <guest-if>"
        echo "  $0 exists <container> <guest-if>"
        exit 1
        ;;
esac
